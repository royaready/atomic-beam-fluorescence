# atomic-beam-fluorescence
2021-07-09
Roy Ready
roy.a.ready@gmail.com

DOI: https://doi.org/10.5281/zenodo.5087529

The atomic-beam-fluorescence code is written in Python 3.8 and calculates the fluorescence of a directed beam of Maxwell-Boltzmann distributed atoms excited by a weak pumping laser for a given detector geometry, oven geometry, and atom species.
The fluorescence is integrated over the volume covering the intersection of the atom beam and the pumping laser beam: I call this the 'megacube'.
The integral elements are called 'microcubes'.

This code was written with the Spinlab fluorescence test setup in mind.
The angular distribution is constrained by the atomic oven nozzle geometry. 
The intensity of the distribution is significant at large angles, and requires a generalized treatment of the fluorescence calculation.

There are several default output files generated by the main program, simulate_ABF.py:

[timestamp]-[species]-eta-yield.pdf : a plot of the photons emitted per atom ("eta") vs. excitation laser frequency
[timestamp]-[species]-abfsim-power.pdf : a plot of the fluorescence power incident on the detector vs. excitation laser frequency
[timestamp]-[species]-abfsim-R-exc.pdf : a plot of the atom excitation rate vs. excitation laser frequency
[timestamp]-[species]-abfsim-maxboltz.txt : a tab-delimited datafile containing parameters of interest:
Col1: laser freq (Hz) # pumping laser frequency
Col2: APD (V) # voltage on detector
Col3: power (W) # power on detector
Col4: eta # photon-per-atom yield
Col5: atom  rate (1/s) # atom rate exiting oven
Col6: Omega (rad) # solid angle from detector to fluorescence origin 
Col7: R_excite (s^-1) # atom excitation rate 	 
Col8: laser power (mW) # pumping laser power  	 
Col9: laser radius (mm) # pumping laser radius 	 
Col10: oven temp (C) # oven temperature 	 
Col11: nozzle # nozzle aspect ratio = 2*radius / (nozzle length)
  
There are three python files:
simulate_ABF.py : Main program. Inputs are atomic species (default = 'Rb'), angular distribution (default = 'molecularflow'), and scantype (default='test'). 
When scantype is set to 'test', the microcubes are set to be quite large so that the execution time of the program is about a minute.
This is useful if you make changes to the code and want to quickly verify that you haven't broken anything.
The full, accurate calculation (scantype = 'fullscan') takes 10--20 hours, depending on the angular distribution you choose and the computer you're running it on.
  
abf-eqns.py : A bunch of functions, such as the excitation rate calculation, that is referenced by the main program.
It makes the main code much more readable.
  
abf_constants.py: A bunch of constants, e.g. the speed of light or the lifetime of an excited state, that is referenced by the other two programs. 
  
The code runs out of the box. Clone the repository and run simulate_ABF.py . Change the atom species, apparatus geometry, and/or angular distribution to suit your application.
